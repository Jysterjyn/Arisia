自分が考えた数学定義
注意⚠　文字に入れる数字は2以上の自然数

【指数の拡張（回転指数）】
数字の右上に小さい数字を書くと冪乗、左上に書くとテトレーションを表していた
ここでペンテーションやヘキセーションを指数で表せないかと考える
hyper5の計算を数字の右下、hyper6の計算を数字の左下に書く
hyper7以降は一周してまた右上に戻り、基準の数字の右に[n]と書く。このnは指数の周回数で、演算レベルが4増えると1増える。[0]は省略する

【タワー表記の拡張】
aⁿ↑b=↑の左上に数字がある場合を考える
=a↑^(a↑^(↑^(n-1重括弧)b)b)b
これは、数字を当てはめていけば分かりやすい
a ¹↑b=a^b
a ²↑b=a↑^(a^b)_b
3 ²↑3=3↑⁹b
3 ³↑3=3↑^(3↑⁹3)_3

などと表されるこれ以降も同様になる。指数も同じく新定義で表せる
基本↑^c[n]で表されるときは指数は右上にある状況

【チェーン表記の拡張】
チェーンからタワーへの変換方法も変える
a→b→c=
↑の次数と回転数は以下のようになる

a↑^c[a↑^c_b]↑……a↑^c[a↑^c_b]
　　　　　　   　︸(a↑^c[a↑^c_b]_b層)
a↑^c[a↑^c_b]↑……a↑^c[a↑^c_b]
　　　　　　   　︸
　　　　   a↑^c[a↑^c_b]_b
次数と回転数が↑の数に置き換わる。そしてそれで出来た数も次の次数と回転数に置き換わる。それを
a↑^c[a↑^c_b]_b回繰り返す

3→3→3→3

=(3→3→3→3)→(3→3→3→3)…3→3→3→3個の
(3→3→3→3)…→(3→3→3→3)

=3→3→3→3→3→3→3→3…()を全て外す…→3
(↑これをAとする)

=(A)→(A)→(A)→(A)…(A→A→…2→3)→2
展開作業を繰り返す度にAの3をAにする
↑しかし展開している()内はしない
他の数字でも同じ
そしてチェーン3つにして強化タワー表記にする

・a→a→…b個…a=a→²b
・a→ⁿa→ⁿ…b個…a=a→^n+1_b
・a→²b→²c=a→²(a→²(b-1)→²c)→²c-1
・a→ⁿ……a
　　　︸
　a→ⁿ……a　　　　　=a↔n
　　　︸a→^n+1_a層
　a→ⁿ…a個…a

・a↔nの展開式の→ⁿを↔にしたもの=a↔²n
・↔の次の矢印は横の列が↑の数、起点の数も仝
その次の矢印は縦にその数…と繰り返される

これらを関数に落とす（HC=Hyper Chain）
HC[a,b,c]d
a=最小の数字の単位
b=繰り返しのレベル（上ではn、a=1,b=0で省略）
c=演算レベル（上では→や↔。c=1で省略）
dは1減らす度にa,b,cをそれぞれHC[a,b,c]にする
HC[a,a,…b個]=HC[a/b]
HC[a/b/c/d]=HC[a/b/HC[a/b/c-1/d]/d-1] cかdは1でそれより右は切り捨て
HC[a/ⁿb]=HC[a/^(n-1)/^(n-1)…b個]
HC[a/ⁿa/ⁿ…b個]=HC[a/^n+1_b]
HC[a,b,c]d/ⁿ=HC[HC[a/ⁿb/ⁿc]/ⁿHC[a/ⁿb/ⁿc]/ⁿHC[a/ⁿb/ⁿc]]d-1/ⁿ

【cを増やす】
cを3にすると、
①a↔ⁿbをAとする
②全ての文字にAを代入し、それをBとする
③B}…B列…}B　←高さがB段で完成

4以降は、①で、仮にc=3の展開式をAとすると、それをAとする②は同じで、③はc+1のチェーンの展開と同じ展開式になり完成。

cはかなり複雑だが、dの次に強くできる数。[]内の数字の個数が4個以上だと、cが強化され、莫大な数になる

【連続関数代入】
Continuation insert(連続挿入)の頭文字2つをとってでCi(n)。これで、例えばグラハム関数のGⁿのやつを定義できる
Ci(64)をGに代入するとG^64となりグラハム数となる
つまりCiは今までで言う次数を表している
一次低いものの答えを次の次数の変数にする回数を表す。さっきのグラハム関数に行った動作を
Ci(64)∈G(4)と表す。集合の要素を表す記号である

Ci(a)∈Ci(b)∈f(x)=Ci(Ci(b)∈f(x))

Ci*(n)=
Ci(n)∈Ci(n)∈……f(x)
　　　　　　  ︸
Ci(n)∈Ci(n)∈……f(x)
　　　　　　  ︸　　}〃}…Ci(n)∈f(x)個…Ci(n)∈f(x)
　　　　　Ci(n)∈f(x)

【関数と"/"】
関数はf(x)が基本形だが、自分が扱っている関数では2つ以上の数字が入る場合が多い。なので
","の代わりに"/"を使うことがある
(a/b)で(a,a,…b個)、(a//b)もしくは(a/² b)で(a/a/…b個)
/が複数ある場合、そのままでは展開できない
だから新チェーン表記計算法で減らしていく
新チェーン表記法は、今までより莫大に数を増やせるのが特徴で、より複雑化している
/のテトレーション(a ²/b)や、回転指数(a/ⁿ[m]b)も
使える。テトレーションの展開は、関数で出た数を/の右上に連ねるP(a ²/b)=P(a/^(P(a ²/b))_b)
他も仝。これはこれまでに何回かでてきたが、
タワー表記に依存しているものだ。 タワー表記に依存するものもあればもちろんチェーン依存しているものがある。それは、P(a\n\b)だ。これで
P(a/ⁿ[P(a/ⁿ[(P…n重…P(a/ⁿ[b]a))]…]/ⁿ[〃]…a/ⁿ[〃]個…a)
となる（[]の中身を踊り字にしている。周回数）
この表記法ももちろんチェーンと同じことができる
回転指数なども同じようなことができる
a\ⁿbはa\^n-1_a…b個となり、n≧2の時は数を2つにしてから展開する

【グラハム関数】
今まで書いてあったものは無駄なので消した
しかし頑張ったので別のところに移しておく

①HC[n ⁿ\n ⁿ\…n ⁿ\n個]HC[n ⁿ\n ⁿ\…n ⁿ\n個]=HC(n)とする
G{1}(n)=Ci*(HC(HC(HC(…HC(n)重…HC(n))…)))
∈〃∈…〃個…〃

ⁿ\は\に^HC[n\n\n]nがn個連なる
\の後に回転数を表すHC[n\n\n]nが省略されている

nをG{1}(n)に置き換えたらG{2}(n)になり、G{2}(n)に置き換えたらG{3}(n)になる{}の数字がG{1}(n)になったらG^a{1}(n)になる。そしてnがG²{1}(n)になると1が2になる。{}の数字がG²{1}(n)になるとG³になる。それを繰り返す。aがG{1}(n)になるとⁿGになる（都合によりnにした）。aが²G{G{1}(n)}(G{1}(n))になると右下指数になる。aがG3{²G{1}(n)}(²G{1}(n))=3G（大文字で表しているが、指数である）。そういう規則で繰り上がっていく。

それを関数にすると完成
G(a,b,c)=↑のn（最弱）=a、{}の数字=b、Gの次数（最強）=n。またいつものあれが使える。G(a/b)など

②Gⁿ[n]{n}(n)のnに、Gⁿ[n]{n}(n)を代入した回数を表したもの=@(a)で表す
@(a)のaに@(a)を代入〃=@(a,b)
@(a,b)のbに@(a,b)を代入〃=@(a,b,c)
と繰り返される。
@(a/b/c)=@(a/@(b/c))
@²(a)=@(@a\^@a[@a]…@a個)
@³(a)=↑の@aを@²aにする
²@(a)=@^@(a)_(a)

Ci@(2-a)=↑の指数、回転数、()の数を全て@^@(a\^a…a個)_(a\^a…a個)
にしたもの
Ci@(3-a)=〃を全てCi@(2-a)にしたもの
Ci@(2,2-a)=Ci@(Ci@(2-a)-a)
Ci@(2,3-a)=Ci@(Ci@(2,2-a)-a)

Ci@(a\^a_a…Ci@(a\^a[a]_a…a個-a)個)をCi*@(2-a)とする
上のaをCi*@(2-a)にするとCi*@(3-a)あとはCi@とほぼ同じ。Ci@は次数をつけられ、Ci*@(2-a)の場合は
Ci*@²(2-a)=Ci*@(Ci*@(2-a)-Ci*@(2-a))となるCi@でも同じ。省略されているがCi@(a\^a_a…Ci@(a\^a[a]_a…a個-a)個)である。
紛らわしいので
Ci*@ⁿ[n](n\ⁿ[n]n…Ci*@ⁿ[n](n\ⁿ[n]n…n個)個-n)
nに↑を↑回代入した数を₫(n)（ドンエヌ）という事にする。()の中身はいつもの感じでOK
③₫(…)ⁿ=括弧の中身の数字を全て₫(…)にする作業をn回。
₫ⁿ(…)'=括弧の中身の数字を全て₫ⁿ-¹(…)'にする。'は変数の変わり、'よりも先に₫ⁿを計算、次数が1になったら
'を外す(内側から)
例）₫²(3)²=₫(₫(3)²)²=₫(₫(₫(3)))²
=₫(₫(₫(₫(₫(3)))))
₫³(2,2)³=₫(₫²(2,2),₫²(2,2))³
₫(₫(₫(2),₫(2)),₫(₫(2),₫(2)))³
↑の2を↑全体の数にする作業を2回やる
()の要素が₫(a,b)にしてからアッカーマン方式で統合をし、3つ以上は強化チェーン方式で統合する
結合する前に数字を₫(…)にしてから計算する

₫(❛₫^₫(n)[₫(n)]❛\^❝_❝…❝)❝を₫(N)とする
nを↑の数に置き換えて出来た数字をnに↑回代入した数を2₫(n)とする。₫→2₫、n→2₫(n)にすると3₫(n)
となる。()の中に複数の数字があったり指数がある場合は先に外す。a₫の場合、指数を外す時は₫もa₫にする。

【アッカーマン数列】
最初は1,1からスタートし、次はAck(1,1)の答えをいれる。1,1,3になる。次にAck(1,1,3)を計算し、その答えが次の項になる。それを繰り返す

【次なる指数】
a#b=b₫(b₫(b₫(b\→^b_b)重)₫→^b_b(n\^b_b…₫(b)個)
b\→^b_bはb→^b_bを指数まで展開した次数
₫→^b_bはb₫(b₫(b₫(b\→^b_b)重)→^b_bを指数〃
a#bは↑の数を指数に直した次数を表し、回転指数より遥かに強い。aがないのは記号にも対応するため

a##b=a#(a#b)
a#^(a#b)=a##…a#b個の#…##b

a#ⁿbの時、指数は本来の指数ではなく#の数を表す

【新たなる関数】
関数を強化する装置を作る。ふぃっしゅ数みたいな物

強化される関数f(a)=a₫(a)

装置1 E¹(a)=【f(a):a→Ci(f(a))∈a₫(a)】
f(a)のaをf(a)回a₫(a)にする
1回目の強化=(a₫(a))₫(a₫(a))
2〃=(a₫(a)₫(a₫(a)))₫(a₫(a)₫(a₫(a)))
となる

装置2 E²(a)=【E¹(a):a→Ci(E¹(a))∈E¹(a)】
E¹(a)のaをE¹(a)回E¹(a)にする
1回目の強化=E¹(E¹(a))
2〃=E¹(E¹(E¹(a)))

装置3以降【】内のEの次数を1つずつ増やす

［指数］
²(E¹(a))（テトレーション）=E^E¹(a)_(a)
³(E¹(a))=E^E¹(a)^E¹(a)_(a)
²(E¹(a))=E¹(a)↑↑2
E¹(a)↑↑↑3=E¹(a)↑↑E¹(a)↑↑E¹(a)　　など
もちろん(E¹(a))#2などもできる

ウルトラ拡張装置(uEⁿ)
上記の装置を拡張したもの
拡張装置1 uE¹(a)=(E¹(a))#^(E¹(a))_
(E¹(a))……(E¹(a))
　　　︸
(E¹(a))#^(E¹(a))_
(E¹(a))……(E¹(a))
　　　︙　　　}〃}…(E¹(a))#^(E¹(a))_(E¹(a))列…}〃

スーパー拡張装置(sEⁿ)
uEの拡張。sE¹は
↑のE¹(a)をuEⁿ#uEⁿ(a)_#…uEⁿ#uEⁿ(a)_(a)個…(a)
にする(#の次数はuEⁿ)

【拡張装置の利用】
sEⁿ(x)は関数。nの次数をsEⁿ(n)回sEⁿ(n)にする(①)
①回①にする。○の数がsEⁿ(n)になるまで続ける
xをsEⁿ(x)を基本とするsEⁿ(x)段のタワー型表記
(a→b→c→2の展開図の形)にする
そしてその縦横拡大をsEⁿ(x)回する
上二つの作業をしたものをs²Eⁿ(x)とする
sⁿ*にするのも同じ作業。sEⁿ(n)をsⁿ*Eⁿ(n)にする
(ⁿと区別するために*を入れました)

【#の強化】記号は変えず、中身を変える
a#b=sE#(sE#(…)…)
(…)の部分をsE#(sE#(…sE#sE^b(b)…)回縦横拡大する
sの指数は↑のsに¹を代入する（つまりそのまま）と出てくる値(①)をまんまsの次数にするその作業を
s^(①)回する。↑の#の次数はsE#(sE#(…sE#sE^b(b)…)
※₁ aは数字じゃなくて記号でもOK
※₂ ↑に出てくる「#」は古い意味での#

【元グラハム関数最大の記号にsE関数を包含する】
元グラハム関数の最小の単位の変更
昔作ったグラハム関数の¶にsEを入れる
a¶b=sE#sE#…sE#(b)…をaⁿに直す=¶(a,b)
そしてそのままζ関数まで進む

【超ツリー関数】
Tree(1),Tree(2)は大した値では無いが、Tree(3)はあのとてつもない数のふぃっしゅ数V6も超すらしい。そんな関数にζ関数を融合させる
Tree*(x)=Tree(Ci(x)∈ζ(Ci_x)x)
これをTree(Tree(…Tree(Ci(x)∈ζ(Ci_x)x)回…
Ci(x)∈ζ(Ci_x)x))回反復合成したら完成

Tree*(x)も反復合成できる
Tree²*(x)=Tree*(Tree*(x))となり、普通関数と同じ
ただのツリー関数ですらふぃっしゅ数バージョン6を余裕で超すんだから拡張しまくったこの数は凄まじい数になるのは間違い無しだ

【a¶b】
a¶b=sE#sE#…sE#(b)…をaⁿに直す=¶(a,b)
a¶b¶c=a¶(b¶c)
a¶ⁿb=a¶ⁿ-¹a¶ⁿ-¹a…b個
¶(a,b,c…n個)=新チェーン方式で減らす
¶ⁿ(a,b,c…n個)はnを1減らす度に()の数字全てを
¶(a,b,c…n個)にする

【a†b】
¶#^a_a#^a…(a個)…(a¶#^a_a,a¶#^a_a…a¶#^a_a個)=α

¶#^α_α(α,α…α,α)
　　　　 　︸
¶#^α_α(α,α…α,α)
　　　︙(¶#^α_α(α,α…(α個)α))
¶#^α_α(α,α…α,α)
　　 　　　︸
¶#^α_α(α,α…(α個)α)
　　　　　　　　︸(横の列数)
¶#^α_α(α,α…α,α)
　　　 　︸
¶#^α_α(α,α…α,α)
　　︙(α(α,α…(α個)α))
¶#^α_α(α,α…α,α)
　　　 　︸
¶#^α_α(α,α…(α個)α)

†は次数や()をつけることができる
†^n=上の式の因数のαをα†^(n-1)_αに
†(n)=式の起点であり、層の数でもある
¶#^α_α(α,α…(α個)α)を
¶#^α_α(α†^(n-1)_α,α†^(n-1)_α…α†^(n-1)_α個)に
†^m(n)=因数のαをα†^(m-1)_αに、起点と層を
¶#^α_α(α†^(n-1)_α,α†^(n-1)_α…α†^(n-1)_α個)にする。次数から先に計算

関数
a,bは、αに変換する
†(a)=a†^a(a)_a=α†^α(α)_α←下のa,bも同様に変換
†(a,b)=(a†b)†^(a†b) (a†b)_(a†b)
†(a/b)=(a†a†…b個)†^(a†a†…b個) (a†a†…b個)_(a†a†…b個)
†^n(a/b)=(†^(n-1)(†^(n-1)…†^(n-1)個))を(†n)とする
(†n)†^(†n) (†n)_(†n)

【λ(ラムダ関数)】
λ(a)=†(a/a)
λ(a,a…n個)=†(†(a,a…n個)…†(a,a…n個))
λ(a/b)=λ(a,a…b個)
λ(a/a/a)=λ(a/(λ(a/a)))　数字3つ以上は一番右側の二つから計算
λ(a//b)=λ(a/a/…b個)
λ(a/^n_b)=λ(a/^(n-1)_λ(a/^(n-1)…b個))
λ(3///3)=(括弧の中だけ書く)
=3//λ(3//3)=3//λ(3/3/3)=3/3/…λ(3/3/3)個
λ^n(〜)=λ(λ^n-1_(〜))　〜には1次の時と同じような数を入れられる。2つとも()の中身は同じ
aλ=λ^a…a重の括弧…(λ^a(λ^a(a/^a_a),…a個),a個)…

a/µ=(aλ(aλ(…aλ重の括弧)))λ
a/µ/n=↑のaλをa/μにする。それはa/µ/2となる。
それを代入しまくって、nの数にする
a/µ/λ=a/μ/(a/µ/aλ)λ

これは次数はない

【aΔb】
a∆b=(aλ/μ/bλ)/…(aλ/μ/bλ)　右側から計算
(aλ/μ/bλ)/(aλ/μ/bλ)=(aλ(aλ(…aλ重の括弧)))λのaλを
(aλ/μ/bλ)に置き換えたもの

∆の数が増えて数字の数が増えても、右端から計算する
これは基本どの公式でも同じだからカット
これは次数がある。次数増えたら、一次低い時の数をa,bなどに代入するだけなので、今後カット(例外は除く)

公式⑧
a‡b=久しぶりに豪快な拡張
まず、(a∆b)∆^(a∆b)_(a∆b)を計算（①）
①を①のa,bに代入、それを①回分繰り返す（②）
(②∆②)∆^(②∆②)_(②∆②)…(②∆②)個（③）
③の②を③にし、横に連ねる数を進数式の
10を(③∆^③_③)、¶(関数の部分も変える)を
∆^(③∆③)にする（④）
④∆^④_④…④個を④‘1’、④に④‘2’、それを
α進数のα桁まで続ける（⑤）
⑤の④を⑤にして、⑤と同じ作業、それを⑥とし、○の中の数がα進数のαまでやる（完成）
次数はある。‡の次数を1減らし、a,bをa‡bに変える。数字の個数は増やせる

公式⑨
‡(a)=a‡^(a‡a…a個)_a‡^…(a‡a…a個)
‡(aa)=‡((a‡a…a個),(a‡a…a個)…(a‡a…a個))

更に強化する
Γa=(a‡a…a‡a個・‡の次数はa‡a)を、γ(ガンマ)とする
=γ‡γ‡…(γ‡γ…γ個)　‡の次数は全てγ‡γ
nΓa=上のaを全て(n-1)Γaにする
Γ²a=Γa Γa…Γa個　左から計算
nΓ²a=Γ²a Γ²a…n個
Γ³a=*(Γ²a Γ²a…Γ²a個)　(↑のnの数が*個である)
ΓⁿaはmΓⁿ-¹aのmが(Γⁿ-¹a個)-1個連なった数になっている
︙

Δ(デルタ大文字)
Δa | Γa Γa …Γa(Γの次数はΓa)を*とし、
↑のaを*に変えたものを**これを繰り返し、
*が(GβΓ^Gβ_Gβ GβΓ…GβΓ^Gβ_Gβ個)になるまで繰り返した数を'とする
'も*と同じように繰り返す↑のGβを'置き換えた回数になったら"に繰り上がり、同じような作業をGβ進数のGβ桁回まで繰り返す。

Δa,b | ΔaとΔbを計算する。そして
aΔb | Γ^Δa_Δb Γ^Δa_Δb…Γ^Δa_Δb個をγと置く
=Γ^γ_γ Γ^γ_γ…Γ^γ_γ個
Δ(a/n)=aΔaΔa…n個=Γ^ΔaΔa…n個_ΔaΔa…n個
Δ(a/b/c)=(aΔa…n個)Δ(aΔa…n個)…Δc個
︙

この公式最後に沢山の反復をやっとく
基礎=Δ^a(a/a/…a)
これを計算してでた数字をaに代入する。その計算を
↑のaにΔ^Gβ(Gβ/Gβ/…Gβ)回繰り返したものを
§aと表す。§(§Gβ)をグラハム数シータ(Gθ)という

新しいものを定義する

そして、Ci(Gθ)∈§Gθをθ進数という

公式⑩
ついに最後となった。§を拡張する
§a/b=§a,a…b個=§(§(…(§(b)重)(§a…))
最初の括弧は§aで、それが次の§aのaになる。
それを§b重
Ci(2)を入れると§(§a/b)/(§a/b)となる。これをこのように強化する。
Ci(Ci(§a/a)∈§a/a)∈A(a)=Ci(§a/a)∈§a/a
右辺の計算をしたら、Aの関数で出た答えを左辺のCiの括弧の中分だけ計算し続ける。これをBとおき、aをBに置き換えてから同じことをする。その作業を
〈(§θ)進数の(§θ)桁桁桁桁をΘとする〉
(§(Θ桁桁))進数の(§(Θ桁桁))桁桁回繰り返したら
ζ(ゼータ)aになり、aに繰り返した数を代入するとζ進数になる

この関数も終焉に向かう
Ci(ζ(ζ(…ζa重)∈…Ci(ζ(ζ(…ζa重)個…
ζ(ζ(…Ci(ζ(ζ(…ζa重)重をまたaに代入するのを←の回数分して、それをまた↑の回数代入する。その回数を表したものをζ(Ci_n)aで表す
そしてζ(Ci_(ζ(Ci_n)a))aのように次々同じように代入していくのをCi(m)∈ζ(Ci_n)aと表す。これで最後
m,n,aにΘを入れて計算そしてまたm,n,aに入れる作業をm,n,aにΘを入れて計算して出てきた数回繰り返す。そして同じ作業をΘ桁桁桁…(Θ桁桁桁…Θ桁)分だけ繰り返す。これがGζΘである

【連続関数代入の拡張】
これからは新しい巨大数を作る関数は一番でかくできる関数を繰り返させるようなものを作る

f(x)を関数とする
Ci*(a)∈f(x)=
Ci{f(f(…  …)}∈f(x)
　　　︸Ci{f(f(…Ci(a)∈f(x)重…)}∈f(x)層
Ci{f(f(…Ci(a)∈f(x)重)}∈f(x)

をAと置くと、a,xを↓の数に変えて変換する作業を
Ci{Ci(A)∈Ci(A)…Ci(A)∈f(A)個…f(A)}∈f{左の括弧と同じ}回繰り返す。Ci*(a,b)と置くと、↑でできた数を↑のaの部分にbを置いた時の数分だけ代入作業を繰り返す。Ci*(a,b)=Ci*(b)∈Ci*(a)とも書ける
3つ目の数字は、Ci*の数を表す。4つ目以降はCi*(a)∈f(x)で統合され、最終的に3つ目の数字になる
Ci*(a/b)=Ci*(a/a…b個)
Ci*(a/b/c)=Ci*(a/a…Ci*(b/c)∈f(x)個)
/ⁿともできる。それはタワー表記と同じ方法で展開する
チェーン表記にも対応、/((a↔ⁿb…)Rc)と表記
数を出さなきゃいけない所はCi*(a)∈f(x)に数字を入れて統合していく

Ci*(f*(x))=Ci*(f(f(…f(x)重)…)　↑まで分解し、↑を/にする。↑未満の関数はNG
↑をx*[f]で表す。x*yで横幅を表す数がf(y*)層
最初は↑と同じ。xが横に増えると縦横に拡大される
x*y=x*x…
　　　︸
　　　x*…
　　　　︸f(y*)層
　　　　x*x…y*個　　となる

a*b*c=(a*b)*c

x*(n)∈…Ciと同じ働きだが、nがn*になる
x*ⁿxの展開はチェーンと一緒だが、次数がn*になる

これからa進数のa桁をa(a)と表す

【垂直記号での強化】
a⊥b=
a*a…
　　︸a*a…b*層
　　a*a…b*個

↑このような形を(3↔3)→2型といい、↖を
(3↔3)→2[a*a…b*個]と表す。3↔4型も同様
a⊥b⊥c=(a⊥b)⊥(a⊥b)…(b⊥c)個
⊥(a)とすれば、a⊥a…(a⊥a…a⊥a個)個

【平方拡張、立方拡張】
Sqn(n,a,演算レベル)はnが均等な幅で正方形状で並ぶ。
nの並ぶ数はa²個。一番右下から計算していく。計算したら左上の方に向かって一つ隣に数を出力する。例えば下のようなものがあったとする
1  1　そしたら右下の1を上左に足し合わせる
1  1　その後、左下でいう2+2+1をする
 ↓
1  2　→5
2

a  b　左のようなものがあった場合、c,b,aの順番で
c　　演算の定義の変数の左の方から当てはめていく
　　　例:c↑↑b↑↑a,c→b→aなど

場所（座標）を指定するのは関数と一緒だが、右下から数えるので注意

これを立体にしたものがキューブナンバー(Cbn)
手前右下から奥左上から計算し、下,左,手前と出力する場所の合計。順番は↗通り

【a∥b】
a∥b=3↔4[a⊥^b_a⊥…(a⊥^b_a⊥…a⊥b)個]
a∥b(s)=Sqn(a∥b,a∥b,∥)
a∥b(c)=Cbn(a∥b,a∥b,∥)
スクエア数とキューブ数は↖のように簡単に導入できる
a∥ⁿb=a∥ⁿ-¹a∥ⁿ-¹…b個
a ⁿ∥b=n-1回だけ∥の次数にa∥bがつく
a (ⁿ+^c)∥b=n-1回だけ∥の次数にa ∥b+^(c-1)がつく
∥(a)=a (a_+^a)∥a…a個

【平方関数の拡張】
平方総計=（Sqs）平方関数で出てきた数字を同じ演算レベルで計算した合計の数。+なら総和、×なら総積、^なら総冪

平方四形=Sqf(n[マス目の縦横の数],a[基本数字])
奇数²のマス目の一番真ん中のマスを起点にする
（足し算・↓は5²マスの場合）
②真ん中のマス+角のマスの数を足す
③四隅の数+真ん中のマスの数
④横のマスが2少ない長方形→縦のマスが2少ない長方形の順番で②,③を繰り返す
のさ
⑤四辺の真ん中のマスだけ残ったらまた同じ作業
それを繰り返し、中心のマスに接しているマス+中央の数をする。と↓の⑤のようになる

①　　　　②　　　　③　　　　④
1 1 1 1 1 　2 1 1 1 2 　2 1 1 1 2　2  10 1 10 2
1 1 1 1 1 　1 1 1 1 1 　1 1 1 1 1　1  1   1  1   1
1 1 1 1 1 →1 1 1 1 1 →1 1 9 1 1→1  1   9  1   1→
1 1 1 1 1 　1 1 1 1 1 　1 1 1 1 1　1  1   1  1   1
1 1 1 1 1 　2 1 1 1 2 　2 1 1 1 2　2  10 1 10  2

2  10 1 10 2　2   10  1  10  2　2   10  1  10  2
1  1   1  1   1　50 1   1   1  50　50 1   1   1  50
1  1 49  1   1→1   1  49  1   1→1   1  249  1   1→…
1  1   1  1   1　50 1   1   1  50　50 1   1   1  50
2  10 1 10 2　2   10  1  10  2　2   10  1  10  2

⑤
2        10        250        10        2
50    1250    6250     1250     50
250  6250   31249    6250    250
50    1250    6250     1250     50
2        10        250        10        2

【Ci*の新定義】
Ci(a)*∈f(x)=a↔4[Ci(a)∈Ci(a)∈…f(x)]

・Ci(2)∈Ci(2)∈Ci(2)∈f(2)=x
=Ci(2)∈Ci(f(2)=x+3)∈f(2)=x+3
=Ci(2)∈Ci(5)∈f(2)=x+3
=Ci(Ci(5)∈f(2)=x+3)∈f(2)=x+3
=Ci(17)∈f(2)=x+3
と計算。一番右のCiとfが一つ左のCiに飲まれ、Ci一つが消滅する

【平(立)方連続関数代入】
平方拡張、平方総計じゃ弱いので、平方四形を使う。
Ci(2)∈Sqf(n,a)はSqf(n,a)はSqf(Sqf(n,a),Sqf(n,a))となる
Ciの中の数が増えるとSqfの()の数も増える
Ci*も同様

【ハイパー演算子の拡張】
Ci(x)∈hyper(a,n,b)=xが1増えるたびにa,b,nに増える前の関数を入れる。

【∥の拡張】
  b（テトレーションのb）
a ∥a=hyper4(a,b,∥)

…a(テトレーションb個)
a ∥a=hyper5(a,b,∥)